<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Clarete, Clavecillas, Salera, Saligumba">
<meta name="dcterms.date" content="2024-09-15">

<title>Thesis (Clarete, Clavecillas, Salera, Saligumba) - Preliminary Concepts</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Thesis (Clarete, Clavecillas, Salera, Saligumba)</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Preliminary Concepts</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Definition</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Clarete, Clavecillas, Salera, Saligumba </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">September 15, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>The following concepts included in here are the concepts that will be used in this Thesis Blog.</p>
<section id="concepts" class="level1">
<h1>Concepts:</h1>
<section id="parametric-family-of-distributions" class="level2">
<h2 class="anchored" data-anchor-id="parametric-family-of-distributions">1. Parametric Family of Distributions</h2>
<p>The Parametric Family of Distributions are divided into 2 categories: Discrete and Continuous.</p>
<section id="discrete-distributions" class="level3">
<h3 class="anchored" data-anchor-id="discrete-distributions">Discrete Distributions</h3>
<ol type="1">
<li>Discrete Uniform Distributions</li>
<li>Bernoulli Distribution</li>
<li>Binomial Distribution</li>
<li>Hypergeometric Distribution</li>
<li>Poisson Distribution</li>
<li>Geometric Distribution</li>
<li>Negative Binomial Distribution</li>
</ol>
</section>
<section id="continuous-distributions" class="level3">
<h3 class="anchored" data-anchor-id="continuous-distributions">Continuous Distributions</h3>
<ol type="1">
<li>Uniform Distribution</li>
<li>Normal Distribution</li>
<li>Gamma Distribution</li>
<li>Exponential Distribution</li>
<li>Beta Distribution</li>
<li>Cauchy Distribution</li>
<li>Lognormal Distribution</li>
</ol>
<hr>
</section>
</section>
<section id="probability-mass-function-pmf-and-probability-density-function-pdf" class="level2">
<h2 class="anchored" data-anchor-id="probability-mass-function-pmf-and-probability-density-function-pdf">2. Probability Mass Function (PMF) and Probability Density Function (PDF)</h2>
</section>
<section id="maximum-likelihood-estimations-mle" class="level2">
<h2 class="anchored" data-anchor-id="maximum-likelihood-estimations-mle">3. Maximum Likelihood Estimations (MLE)</h2>
</section>
<section id="estimation-maximization" class="level2">
<h2 class="anchored" data-anchor-id="estimation-maximization">4. Estimation Maximization</h2>
</section>
<section id="law-of-total-probability" class="level2">
<h2 class="anchored" data-anchor-id="law-of-total-probability">5. Law Of Total Probability</h2>
<div class="line-block">The <strong>Law of Total Probability</strong> is a fundamental rule relating marginal probabilities to conditional probabilities. It states that if you have a set of mutually exclusive and exhaustive events, you can compute the probability of another event by summing the conditional probabilities of that event with respect to each of the mutually exclusive events, weighted by the probability of each event. |<br>
Formal Definition Let <span class="math inline">\(B_1,B_2, ..., B_n\)</span> be mutually exclusive and exhaustive events (i.e., one of them must occur), and let <span class="math inline">\(A\)</span> be any event. The Law of Total Probability is expressed as: |<br>
<span class="math display">\[                                                                                                                                                                                                                                                                                                                                                                                                                P(A) = \sum_{i=1}^n P(A|B_i)P(B_i)                                                                                                                                                                                                                                                                                                                                                                                \]</span> |<br>
where: |<br>
- <span class="math inline">\(P(A)\)</span> is the total probability of A. |<br>
- <span class="math inline">\(P(A|B_i)\)</span> is the conditional probability of <span class="math inline">\(A\)</span> given <span class="math inline">\(B_i\)</span>. |<br>
- <span class="math inline">\(P(B_i)\)</span> is the probability of <span class="math inline">\(B_i\)</span>, where <span class="math inline">\(B_i\)</span> are mutually exclusive events (i.e., <span class="math inline">\(P(B_i \cap B_j) = 0\)</span> for <span class="math inline">\(i \neq j\)</span> |</div>
</section>
<section id="central-limit-theorem" class="level2">
<h2 class="anchored" data-anchor-id="central-limit-theorem">6. Central Limit Theorem</h2>
<p>The Central Limit Theorem (CLT) is a fundamental theorem in statistics that describes the behavior of the sampling distribution of the sample mean. It states that, under certain conditions, the distribution of the sample mean (or sum) of a sufficiently large number of independent random variables will be approximately normally distributed, regardless of the original distribution of the population from which the samples are drawn.</p>
<p>Key Points of the Central Limit Theorem: 1. Independence: The random variables must be independent of each other.</p>
<ol start="2" type="1">
<li><p>Sample Size: The sample size should be sufficiently large. A common rule of thumb is that a sample size of 30 or more is often considered sufficient for the CLT to hold, although this can vary depending on the original distribution.</p></li>
<li><p><strong>Distribution of the Sample Mean</strong>: if <span class="math inline">\(X_1,X_2,...,X_n\)</span> are independent and identically distributed (i.i.d.) random variables with mean <span class="math inline">\(\mu\)</span> and variance <span class="math inline">\(\sigma^2\)</span>, then the sampling distribution of the sample mean <span class="math inline">\(\overline{X}\)</span> (which is the average of the sample) will approach a normal distribution with mean <span class="math inline">\(\mu\)</span> and variance <span class="math inline">\(\frac{\sigma^2}{n}\)</span> as the sample size <span class="math inline">\(n\)</span> increases</p></li>
</ol>
<p>Mathematical Representation: If <span class="math inline">\(\overline{X}\)</span> is the sample mean, then the CLT can be mathematically expressed as:</p>
<p><span class="math display">\[
\sqrt{n}(\frac{\overline{X}-\mu}{\sigma})  \longrightarrow N(0,1)
\]</span></p>
<p>Where:</p>
<ul>
<li><p><span class="math inline">\(\overline{X}\)</span> is the sample mean</p></li>
<li><p><span class="math inline">\(\mu\)</span> is the population mean</p></li>
<li><p><span class="math inline">\(\sigma\)</span> is the population standard deviation</p></li>
<li><p><span class="math inline">\(N(0,1)\)</span> denotes the standard normal distribution</p></li>
</ul>
<p>Importance: The Central Limit Theorem is crucial for many statistical methods and inferential statistics, as it justifies the use of the normal distribution in various applications, including hypothesis testing and confidence interval estimation, even when the original data is not normally distributed. This allows statisticians to make inferences about population parameters based on sample statistics.</p>
<hr>
</section>
<section id="bayesian-analysis" class="level2">
<h2 class="anchored" data-anchor-id="bayesian-analysis">7. Bayesian Analysis</h2>
<p><strong>Bayesian</strong> Analysis is a statistical approach that applies Bayes’ Theorem to update the probability of a hypothesis as more evidence or information becomes available. Unlike frequentist statistics, which interprets probability as the long-run frequency of events, Bayesian analysis treats probability as a measure of belief or certainty regarding an event or hypothesis.</p>
<p>Key Concepts in Bayesian Analysis: 1. <strong>Bayes’ Theorem</strong>: At the core of Bayesian analysis is Bayes’ Theorem, which provides a mathematical formula for updating probabilities. It is expressed as: <span class="math display">\[
P(H|E) = \frac{P(E|H) \cdot P(H)}{P(E)}
\]</span></p>
<p>Where: - <span class="math inline">\(P(H|E)\)</span> is the posterior probability of the hypothesis <span class="math inline">\(H\)</span> given evidence <span class="math inline">\(E\)</span>. - <span class="math inline">\(P(E|H)\)</span> is the likelihood of observing evidence <span class="math inline">\(E\)</span> given that <span class="math inline">\(H\)</span> is true - <span class="math inline">\(P(H)\)</span> is the prior probability of the hypothesis before observing the evidence. - <span class="math inline">\(P(E)\)</span> is the marginal likelihood or the total probability of observing evidence <span class="math inline">\(E\)</span></p>
<p><strong>Prior Probability</strong>: This represents the initial belief about a hypothesis before any evidence is considered. It is based on previous knowledge or subjective judgment.</p>
<p><strong>Likelihood</strong>: This measures how likely the observed data is under different hypotheses. It reflects the relationship between the data and the hypothesis.</p>
<p><strong>Posterior Probability</strong>: This is the updated probability of the hypothesis after incorporating the new evidence. It combines the prior probability and the likelihood of the observed evidence.</p>
<p><strong>Bayesian Inference</strong>: The process of using Bayes’ Theorem to update beliefs based on new evidence. This inference can be applied to various statistical models, allowing for more flexible modeling of uncertainty.</p>
<section id="advantages-of-bayesian-analysis" class="level3">
<h3 class="anchored" data-anchor-id="advantages-of-bayesian-analysis">Advantages of Bayesian Analysis:</h3>
<ul>
<li><p><strong>Incorporation of Prior Knowledge</strong>: Bayesian methods allow the inclusion of prior knowledge and beliefs, which can improve estimates, especially in cases with limited data.</p></li>
<li><p><strong>Interpretability</strong>: The results of Bayesian analysis are often easier to interpret, as they provide probabilities directly associated with hypotheses.</p></li>
<li><p><strong>Flexibility</strong>: Bayesian methods can be applied to a wide range of problems and can handle complex models, including hierarchical models and missing data.</p></li>
</ul>
<hr>
</section>
</section>
<section id="sampling-methods" class="level2">
<h2 class="anchored" data-anchor-id="sampling-methods">8. Sampling Methods</h2>
<p><strong>Sampling methods</strong> are techniques used to select a subset of individuals or items from a larger population for the purpose of statistical analysis. The goal of sampling is to gather information that can be used to make inferences about the entire population without the need to survey every member. Different sampling methods can impact the validity and reliability of the results obtained.</p>
<section id="common-sampling-methods" class="level3">
<h3 class="anchored" data-anchor-id="common-sampling-methods">Common Sampling Methods:</h3>
<ol type="1">
<li><p><strong>Probability Sampling</strong>: In probability sampling, every member of the population has a known, non-zero chance of being selected. This approach allows for the generalization of results to the larger population. Common types of probability sampling include:</p>
<ul>
<li><p><strong>Simple Random Sampling</strong>: Each member of the population has an equal chance of being selected. This can be achieved using random number generators or drawing names from a hat.</p></li>
<li><p><strong>Systematic Sampling</strong>: Members are selected at regular intervals from a list. For example, every 10th person on a list may be chosen.</p></li>
<li><p><strong>Stratified Sampling</strong>: The population is divided into distinct subgroups (strata) based on a characteristic (e.g., age, gender), and random samples are taken from each stratum. This ensures representation from all subgroups.</p></li>
<li><p><strong>Cluster Sampling</strong>: The population is divided into clusters (often geographically), and entire clusters are randomly selected. This method is useful when populations are spread out over large areas.</p></li>
</ul></li>
<li><p><strong>Non-Probability Sampling</strong>: In non-probability sampling, members are selected based on subjective judgment rather than random selection. This can lead to biases and limits the ability to generalize results to the larger population. Common types include:</p>
<ul>
<li><p><strong>Convenience Sampling</strong>: Members are selected based on their easy availability and accessibility. For example, surveying people at a shopping mall.</p></li>
<li><p><strong>Judgmental Sampling</strong>: The researcher selects members based on their knowledge and judgment about who would be most representative of the population.</p></li>
<li><p><strong>Snowball Sampling</strong>: Existing participants recruit new participants from among their acquaintances. This method is often used in hard-to-reach populations.</p></li>
<li><p><strong>Quota Sampling</strong>: The researcher ensures that certain characteristics are represented in the sample by setting quotas for specific subgroups. However, selection within those groups is not random.</p></li>
</ul></li>
</ol>
</section>
<section id="importance-of-sampling-methods" class="level3">
<h3 class="anchored" data-anchor-id="importance-of-sampling-methods">Importance of Sampling Methods:</h3>
<p>Choosing the appropriate sampling method is crucial because it affects the validity and reliability of research findings. Well-designed sampling methods help ensure that the sample accurately represents the population, reducing bias and allowing for more generalizable conclusions. Conversely, poor sampling methods can lead to misleading results and affect the overall quality of the research.</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>